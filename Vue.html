<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h2>vue优点</h2>
    <ul>
        <li>轻量级框架</li>
        <li>简单易学易上手</li>
        <li>双向数据绑定</li>
        <li>组件化</li>
        <li>数据和结构分离</li>
        <li>虚拟dom</li>
        <li>运行速度快</li>
    </ul>
    <h2>vue 组件传参</h2>
    <ul>
        <li>父向子传参  props</li>
        <li>子向父传参  $emit</li>
        <li>vuex 传参</li>
    </ul>
    <h2>v-show和v-if指令有什么共同点和不同点</h2>
    <ul>
        <li>共同点: 都能控制元素的显示和隐藏</li>
        <li>不同点: 实质方法不同
            <ul>
                <li>v-show 的本质是给元素设置display:none, 来实现显示隐藏</li>
                <li>v-if 的本质 是动态的向dom里添加删除元素, 不停的销毁创建消耗性能</li>
            </ul>
        </li>
    </ul>
    <h2>如何让css只在当前组件内起作用呢?</h2>
    <ul>
        <li>在组件的style 标签添加scoped</li>
    </ul>
    <h2>keep-alive 的作用是什么</h2>
    <ul>
        <li>它是vue内置的组件, 保持组件的状态以免被重复渲染</li>
    </ul>
    <h2>vue 中如何获取dom</h2>
    <ul>
        <li>利用ref refs 来获取</li>
    </ul>
    <h2>vue-loader 是什么? 使用它的用途有哪些</h2>
    <ul>
        <li>解析和转换.vue 文件. 提取其中的逻辑代码script 样式代码style html模板template, 分别找对应的loader去处理 </li>
    </ul>
    <h2>为什么使用key?</h2>
    <ul>
        <li>需要使用key来给每一个节点做一个唯一的标识, 为了高效的更新虚拟dom</li>
    </ul>
    <h2>v-model实现原理</h2>
    <ul>
        <li>v-model 用在表单输入的双向绑定和 输入组件上实现输双向绑定, 他自己本身就是一个语法糖(语法糖就是一种语法, 代码简便, 方便我们去使用, 性能上没有带来损失)</li>
        <li>利用v-bind 单向绑定在输入框上, 绑定一个变量, 再更改变量时, 输入框的值也相应改变, 但是更改输入框的值的时候, 变量无法改变, 这时监听输入框事件, 当触发事件时, 将值赋给变量, 这样实现v-modle</li>
    </ul>
    <h2>分别简述computed和watch的使用场景</h2>
    <ul>
        <li>computed 计算属性  当一个属性受到多个属性的变化是要用到</li>
        <li>watch 当一条数据 改变多条数据的时候 用到watch</li>
    </ul>
    <h2>v-on 可以监听多个方法吗?</h2>
    <ul>
        <li>v-on="{input: input, blur: blur}"</li>
    </ul>
    <h2>$nextick 的使用</h2>
    <ul>
        <li>dom 更新完之后调用, 在修改完数据后使用 会获取到更新完之后dom</li>
    </ul>
    <h2>组件中的data为什么必须是一个函数</h2>
    <ul>
        <li>data 以函数返回的形式定义, 这样每次使用组件的时候, 都会生一个新的data, 相当于每一个组件都有一个独立的数据空间, 只需要负责维护自己的数据, 不会造成混乱, 如果写成对象的形式, 所有组件公用一个data, 改一个全部都在变</li>
    </ul>
    <h2>渐进式框架</h2>
    <ul>
        <li>一个项目你可以只是用我的一部分, 而不是用了这一点就用了所有的部分</li>
    </ul>
    <h2>vue 中双向数据绑定是如何实现的</h2>
    <ul>
        <li>数据绑定是通过数据劫持 结合 发布订阅者模式来实现的, 也就是说 数据发生变化, 视图也会发生变化, 同样试图变化, 数据也发生变化</li>
        <li>核心: 通过Object.defineProperty来劫持各个属性的getter和setter, 在数据发生变动时, 发布消息给订阅者, 触发相应的监听回调</li>
    </ul>
    <h2>单页面应用和多页面应用的区别</h2>
    <ul>
        <li>单页面应用就是 只有一个主页面的应用, 浏览器要加载必须加载所有的js,css, html.</li>
        <li>多页面应用就是 一个应用里面多个页面</li>
        <li>单页面的优点: 快 内容改变不需要重新加载整个页面, 对服务器压力小</li>
        <li>单页面的缺点: 不利于seo, 初次加载耗时多</li>
    </ul>
    <h2>首屏加载慢如何解决</h2>
    <ul>
        <li>ui库 按需加载</li>
        <li>使用cdn资源</li>
        <li>减小入口文件   配置路由使用懒加载</li>
        <li>图片资源压缩</li>
        <li>开启gzip压缩</li>
        <li>静态资源本地加载</li>
        <li>使用服务端渲染</li>
    </ul>
    <h2>vue 生命周期</h2>
    <ul>
        <li>beforeCreate 在实例化后, 只有一些默认的生命周期钩子和默认事件, 其他的东西都还没创建, data和methods 都还没有初始化, 无法获取的到</li>
        <li>created data和methods 都已经初始化完毕</li>
        <li>beforeMount 内存已经编译好模板, 但是还没有挂载到页面上</li>
        <li>mounted 实例化和页面都已经加载完毕  可以获取到元素</li>
        <li>beforeUpdate 页面中显示的数据还是旧的, 但是 data中的数据是已经更新过的, 数据和页面没有保持同步</li>
        <li>updated 页面显示的数据和data的数据已经是最新的</li>
        <li>beforeDestory 实例销毁钱调用 实例仍然完全可用, 还没有真正地销毁</li>
        <li>destroyed 实例销毁后调用, 实例被销毁</li>
    </ul>
</body>
</html>