<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h2>1. 掌握盒子水平垂直居中</h2>
    <ul>
        <li>
            定位三种
            <ol>
                <li>必须有宽高 absolute  top 50% left 50% margin-top(高度的一半) margin-bottom(宽度的一半)</li>
                <li>必须有宽高但不需要考虑宽高 absolute  top 0 left 0 margin: auto</li>
                <li>不需要宽高 兼容性不是很好 absolute  top 50% left 50% transfrom: tranlate(-50%, -50%)</li>
            </ol>
        </li>
        <li>flex布局</li>
        <li>js</li>
        <li>display: table-cell   控制文本的 要把盒子变成文本  父元素要有固定宽高的</li>
    </ul>
    <h2>2. 盒模型</h2>
    <ul>
        <li>标准盒模型  width指content部分的宽度</li>
        <li>怪异盒模型  width表示content+padding+border这三个部分的宽度</li>
        <li>box-sizing: content-box</li>
    </ul>
    <h2>3. 经典布局方案</h2>
    <ul>
        <li>圣杯布局 并排布局 浮动 左侧margin-left:-100%;在加上相对自己宽度的定位  右侧margin-right:-200px;  中间元素使用左右内间距留出左右宽度的距离</li>
        <li>双飞翼布局 将中间内容的元素嵌套起来 浮动 中间元素使用外间距距留出左右宽度的距离 左侧 margin-left: -100%; 右侧 margin-left: -200px;</li>
        <li>左右固定,  中间自适应</li>
        <li>使用 calc  css 语法 动态计算宽度</li>
        <li>flex布局</li>
    </ul>
    <h2>4. 移动端响应方式的三大方案</h2>
    <ul>
        <li>media 媒体查询 百分比</li>
        <li>rem</li>
        <li>flex</li>
        <li>vh / vw</li>
    </ul>
    <h2>5. z-index的工作原理及适用范围</h2>
    <ul>
        <li>z-index 这个属性控制着元素z轴的表现形式</li>
        <li>适用范围: 仅适用于定位元素，即拥有relative,absolute,fixed属性的position元素</li>
        <li>数值越大说明元素的堆叠顺序越高，越靠近屏幕</li>
        <li>未定义时，后来居上，未定义z-index的属性，元素的堆叠顺序基于它所在的文档树。默认情况下，后来的元素的z-index的值越大</li>
    </ul>
    <h2>6. rem px em的区别</h2>
    <ul>
        <li>px 相对于屏幕分辨率而言的</li>
        <li>em 相对于当前对象内文本的字体尺寸</li>
        <li>rem 相对于根节点html字体大小来计算</li>
    </ul>
    <h2>7. html5 的理解</h2>
    <h2>8. 介绍js的数据类型</h2>
    <ul>
        <li>引用类型 Object function </li>
        <li>基本类型 undefined、Null、Boolean、Number、String、Symbol</li>
    </ul>
    <h2></h2>
    <ul>
        <li>堆: 存储引用类型值的空间</li>
        <li>栈: 存储基本类型值和指定代码地环境</li>
    </ul>
    <h2>var let const 的区别</h2>
    <ul>
        <li>var 有变量提升 而let const 是 没有变量提升; 变量提升就是在js中  函数及变量的声明都会被提升到所在作用域的最顶部</li>
        <li>let const 都是块级作用域变量   同一作用域中  let const 是不能进行多次声明的 而 var  是可以的</li>
        <li>const  一但声明, 常量(基础类型)的值是不可以更改的, 但是必须要赋值  let是可以进行更改赋值的</li>
    </ul>
    <h2>箭头函数</h2>
    <ul>
        <li>箭头函数是es6中新的函数定义形式; 箭头函数中是没有this, 是他定义的时候的this, 不是他执行时候的, 他的this指向 是他上层函数的this</li>
    </ul>
    <h2>Set  Map</h2>
    <ul>
        <li>set map 是es6新增的数据结构</li>
        <li>set 类似于数组, 但是数组可以允许元素重复, set是不允许的</li>
        <li>map 类似于对象, 普通对象的key 必须是字符串和数字, 但是map的key可以使任何数据类型的</li>
    </ul>
    <h2>浏览器的渲染过程</h2>
    <ol>
        <li>处理HTML标记 并构建DOM树</li>
        <li>处理css标记 并构建cssom树</li>
        <li>将dom和cssom 合并后才能一个渲染树</li>
        <li>根据渲染树来布局, 以计算每个节点的集合信息</li>
        <li>将各个节点绘制到屏幕</li>
    </ol>
    <h2>重绘和回流(重排)</h2>
    <ul>
        <li>重绘  当元素外观(颜色)发生改变, 产生重绘</li>
        <li>回流(重排) 当元素的布局(尺寸位置)发生改变产生的回流(重排)</li>
        <li>注意：JS获取Layout属性值（如：offsetLeft、scrollTop、getComputedStyle等）也会引起回流。因为浏览器需要通过回流计算最新值 </li>
        <li>回流必将引起重绘，而重绘不一定会引起回流</li>
    </ul>
    <h2>如何最小化重绘和回流</h2>
    <ul>
        <li>减少对dom节点的操作</li>
        <li>减少重复获取节点的一些值, 多次获取会重复造成回流</li>
    </ul>
    <h2>作用域</h2>
    <ul>
        <li>作用域 是指可访问变量, 对象, 函数的集合;在有效的范围内调用变量, 对象, 函数</li>
        <li>全局作用域和函数作用域, 在es6之前是没有块级作用域, 块级作用域</li>
    </ul>
    <h2>原型和原型链</h2>
    <ul>
        <li>每一个对象都会在内部初始化一个属性, 这个属性就是prototype</li>
        <li>所有引用类型, 都有对象特性, 都会自由扩展属性</li>
        <li>所有引用类型, 都有一个__proto__属性, 属性值是一个普通的对象</li>
        <li>所有函数, 都有一个prototype属性, 属性值是一个普通的对象</li>
        <li>所有引用类型, __proto__属性值都指向他的构造函数的prototype属性值</li>
        <li>原型链  当调用某种方法或者查找某种属性时, 首先会在自身调用和查找, 如果自身没有该方法和属性时, 则会去它的__proto__属性中调用和查找,  也就是它的构造函数的prototype中调用查找</li>
    </ul>
    <h2>This的理解</h2>
    <ul>
        <li>this的值在执行的时候确认, 并不是在定义的时候确认,  因为this是执行上下文环境的一部分, 而执行上下文需要在代码之前确认, 而不是定义的时候</li>
    </ul>
    <h2>http和https的区别</h2>
    <ul>
        <li>http是超文本传输协议, 是一种网络协议,  https 是安全版的http, 是以安全为目标的http通道</li>
        <li>http 传输的数据都是未加密的, 也就是明文的, https 是由ssl协议和http构建的可加密传输和身份认证的网络协议, 要比http更加安全</li>
        <li>端口不同 http 80 https 443</li>
    </ul>
    <h2>iframe 是什么?  缺点是什么?</h2>
    <ul>
        <li>iframe元素会创建一个包含另一个文档的内联框架</li>
        <li>缺点: 
            <ol>
                <li>会阻塞主页面的onload事件</li>
                <li>不利于seo 搜索引擎无法搜索到这个页面</li>
            </ol>
        </li>
    </ul>
    <h2>304状态码</h2>
    <ul>
        <li>客户端发送了一个get请求, 而内容与上一次请求的内容并无改变, 则服务器就会返回304这个状态码</li>
    </ul>
    <h2>强缓存和协商缓存</h2>
    <ul>
        <li>浏览器缓存是用户最近请求过的文档进行的存储</li>
        <li>浏览器缓存优点:
            <ol>
                <li>减少冗余的数据传输</li>
                <li>减少服务器的负担</li>
                <li>加快客户端加载页面的速度</li>
            </ol>
        </li>
        <li>强缓存 直接使用本地的缓存,  不与服务器进行通信</li>
        <li>协商缓存 通过服务器来判断缓存是否可用</li>
        <li>区别: 强缓存是不会发送请求的, 协商缓存是可以发送请求的</li>
    </ul>
    <h2>前端优化</h2>
    <ul>
        <li>降低请求量: 合并资源, 降低HTTP请求, 文件压缩gizp, 使用webP图片格式, 图片懒加载</li>
        <li>加快请求速度: 使用DNS资源 </li>
        <li>缓存: HTTP请求缓存</li>
        <li>渲染: JS/CSS优化, 加载顺序, 服务端渲染</li>
    </ul>
    <h2>GET. POST的区别</h2>
    <ul>
        <li>get 参数通过url传递 post request body 传递</li>
        <li>get 是有长度限制的, post 是没有的</li>
        <li>get比post更不安全, get是直接暴露在url中, 不能用来传递敏感字符</li>
        <li>get只能url进行编码, post 有多种编码方式</li>
        <li></li>
    </ul>
    <h2>HTTP支持的方法</h2>
    <ul>
        <li>get, post, head, options, put, delete</li>
    </ul>
    <h2>输入url到页面加载显示完成发生了什么</h2>
    <ul>
        <li>DNS解析  返回ip地址回来</li>
        <li>TCP连接 三次握手来建立连接
            <ol>
                <li>第一次握手 客户端向服务器发送数据的初始序列号(SYN)</li>
                <li>第二次握手 服务器确认客户端发送过来的SYN, 同时想客户端发送SYN和SYN的ACk(表示序列号确认无误)</li>
                <li>第三次握手 客户端收到服务器发来的SYN和ACK, 在向服务器发送确认分节, 客户端和服务器端建立连接, 完成三次握手</li>
            </ol>
        </li>
        <li>发送HTTP请求</li>
        <li>服务器处理请求并返回HTTP报文</li>
        <li>浏览器解析渲染页面</li>
        <li>连接结束</li>
    </ul>
</body>
</html>